
// SpaceInvaders_Game.cpp : This file contains the 'main' function. Program execution begins and ends there.
// Julien Merceron - 2023
// code generated by chatGPT
/*
ChatGPT Dec 15th 2022 Version
https://chat.openai.com/chat
*/
/*
SDL
https://github.com/libsdl-org/SDL/releases/tag/release-2.26.2
SDL2-devel-2.26.2-VC.zip
sdl/include
sdl/lib
wrt dlls, ...
... copy \SDL2\lib\x64\SDL2.dll to C:\Windows\System32
... and \SDL2\lib\x86\SDL2.dll to C:\Windows\SysWOW64. Voila
*/
/*
SDL Image
https://github.com/libsdl-org/SDL_image
TBC
*/
/*
create a CONSOLE APP on VC++
copy paste base code in c++ file
------
add include path to SDL in VC++ Directories
add lib path to SDL in VC++ Directories
add sdl2.lib in libs to link in Linker -> Input
change from console to windows in Linker -> System
*/
/*
PROMPT MODIFIERS
resolution_driven
add_comments
*/



#include <iostream>
#include "sdl.h"
//#include "SDL_render.h"
//#include "sdl_image.h"
#include "sdl_Render_Circle.h"
#include <windows.h>
#include <vector>

#define SCROLLING_STARFIELD 1

// Screen dimensions (as percentages of the actual screen dimensions)
const int SCREEN_WIDTH_PERCENT = 80;
const int SCREEN_HEIGHT_PERCENT = 80;
int screen_width, screen_height;
int game_screen_width;
int game_screen_height;

const int NUM_STARS = 200;
const int STAR_SIZE = 2;
const int MAX_STAR_SPEED = 2;
const int MAX_STAR_ANGLE = 360;
const double MAX_STAR_DEPTH = 3.0;
const double MAX_STAR_DEPTH_SPEED = 0.01;

struct Star {
    int x;
    int y;
    double depth;
    double speed;
    double angle;
};
std::vector<Star> stars;

// Generate random stars
void generateStars() {
#if SCROLLING_STARFIELD
    stars.clear();
    std::srand((unsigned int)std::time(0));
    for (int i = 0; i < NUM_STARS; ++i) {
        Star star;
        star.x = std::rand() % game_screen_width;
        star.y = std::rand() % game_screen_height;
        star.speed = std::rand() % MAX_STAR_SPEED + 1;
        stars.push_back(star);
    }
#else if
    stars.clear();
    std::srand((unsigned int)std::time(0));
    for (int i = 0; i < NUM_STARS; ++i) {
        Star star;
        star.x = std::rand() % game_screen_width;
        star.y = std::rand() % game_screen_height;
        star.depth = static_cast<double>(std::rand()) / static_cast<double>(RAND_MAX) * MAX_STAR_DEPTH;
        star.speed = static_cast<double>(std::rand()) / static_cast<double>(RAND_MAX) * MAX_STAR_SPEED + 1;
        star.angle = static_cast<double>(std::rand()) / static_cast<double>(RAND_MAX) * MAX_STAR_ANGLE;
        stars.push_back(star);
    }
#endif
}

// Update star positions
void updateStars(float deltaTime) {
#if SCROLLING_STARFIELD
    for (Star& star : stars) {
        star.y += star.speed;
        if (star.y >= game_screen_height) {
            star.y = 0;
        }
    }
#else if
    for (Star& star : stars) {
        // Update star position based on velocity and deltaTime
        star.x += star.velocity.x * deltaTime;
        star.y += star.velocity.y * deltaTime;
        star.z += star.velocity.z * deltaTime;

        // Wrap stars around screen edges
        if (star.x < 0) {
            star.x = game_screen_width;
        }
        if (star.y < 0) {
            star.y = game_screen_height;
        }

        // Update star size based on depth
        int starSize = static_cast<int>(STAR_SIZE * (MAX_STAR_DEPTH - star.z + 1));
        star.size = starSize;
    }
#endif
}


///////////////////////////////////////
// Player Ship class //////////////////
///////////////////////////////////////
class Player {
public:
    int x, y;
    int width, height;
    int velocity;

    void update(int screen_width)
    {
        // Check if the player collides with the left or right walls
        if (x < 0 && velocity < 0)
        {
            velocity = 0;
        }
        if (x + width > screen_width && velocity > 0)
        {
            velocity = 0;
        }

        // Update player position based on velocity
        x += velocity;
    }
};
Player mPlayer;

///////////////////////////////////////
// Player ship bullets ////////////////
///////////////////////////////////////
struct PlayerBullet
{
    int x; // X-coordinate of the bullet
    int y; // Y-coordinate of the bullet
    int width; // Width of the bullet
    int height; // Height of the bullet
    int velocity_x;
    int velocity_y;
    bool active;
    SDL_Texture* texture; // Texture for the bullet
    SDL_Rect rect; // SDL_Rect representing the position and size of the bullet
};
const int nbPlayerBullets = 1000;
PlayerBullet mPlayerBullet[nbPlayerBullets];


// Update the bullet's position based on game logic
void fn_vPlayerBullets_Update()
{
    for (int i = 0; i < nbPlayerBullets; i++)
    {
        if (mPlayerBullet[i].active)
        {
            // Update bullet's position based on velocity
            mPlayerBullet[i].x += mPlayerBullet[i].velocity_x;
            mPlayerBullet[i].y += mPlayerBullet[i].velocity_y;

            // Update rect to reflect current position
            mPlayerBullet[i].rect.x = mPlayerBullet[i].x;
            mPlayerBullet[i].rect.y = mPlayerBullet[i].y;
        }
    }
}


// Invaders class
class Invader {
public:
    int x, y;
    int width, height;
    bool destroyed;

    void update()
    {
        if (!destroyed)
        {
            // Update block state (e.g. check for destruction)
            // Check if the ball collides with the block
            for (int i = 0; i < nbPlayerBullets; i++)
            {
                if (mPlayerBullet[i].active)
                {
                    if (mPlayerBullet[i].x > x
                        && mPlayerBullet[i].x < x + width
                        && mPlayerBullet[i].y > y
                        && mPlayerBullet[i].y < y + height)
                    {
                        // If so, mark the block as destroyed
                        destroyed = true;
                        // rearrange list of player bullets
                        for (int j = 0; j < nbPlayerBullets; j++)
                        {
                            if (mPlayerBullet[j].active == 0)
                            {
                                j--;
                                mPlayerBullet[i].x = mPlayerBullet[j].x;
                                mPlayerBullet[i].y = mPlayerBullet[j].y;
                                mPlayerBullet[i].width = mPlayerBullet[j].width;
                                mPlayerBullet[i].height = mPlayerBullet[j].height;
                                mPlayerBullet[i].velocity_x = mPlayerBullet[j].velocity_x;
                                mPlayerBullet[i].velocity_y = mPlayerBullet[j].velocity_y;
                                mPlayerBullet[i].active = mPlayerBullet[j].active;
                                mPlayerBullet[j].active = 0;
                                break;
                            }
                        }
                        i--;
                    }
                }
            }
        }
    }
};
std::vector<Invader> vInvaders;


// Invaders bullets
struct InvaderBullet
{
    int x; // X-coordinate of the bullet
    int y; // Y-coordinate of the bullet
    int width; // Width of the bullet
    int height; // Height of the bullet
    bool active;
    SDL_Texture* texture; // Texture for the bullet
    SDL_Rect rect; // SDL_Rect representing the position and size of the bullet
};

int InvadersBullets_velocity = 1;
const int nbInvadersBullets = 10;
InvaderBullet mInvaderBullet[nbInvadersBullets];


// Update the bullet's position based on game logic
void fn_vInvadersBullets_Update()
{
    for (int i = 0; i < nbInvadersBullets; i++)
    {
        // Update bullet's position based on velocity
        mInvaderBullet[i].y += InvadersBullets_velocity;

        // Update rect to reflect current position
        mInvaderBullet[i].rect.x = mInvaderBullet[i].x;
        mInvaderBullet[i].rect.y = mInvaderBullet[i].y;

    }
}






void fn_vInitObjectsSizeOnScreen()
{
    // Create the paddle
    mPlayer.x = game_screen_width / 2;
    mPlayer.y = game_screen_height - game_screen_height / 9;
    mPlayer.width = game_screen_width / 12;
    mPlayer.height = game_screen_height / 24;
    mPlayer.velocity = 0;

    // Create the player bullets
    for (int i = 0; i < nbPlayerBullets; i++)
    {
        mPlayerBullet[i].active = 0;
        mPlayerBullet[i].x = game_screen_width / 2;
        mPlayerBullet[i].y = game_screen_height - game_screen_height / 9;
        mPlayerBullet[i].width = game_screen_width / 96;
        mPlayerBullet[i].height = game_screen_height / 48;
        mPlayerBullet[i].velocity_x = 0;
        mPlayerBullet[i].velocity_y = -5;
    }

    // Create the invaders
    for (int i = 1; i < 11; i++) {
        for (int j = 2; j < 6; j++) {
            Invader invader;
            invader.x = i * (game_screen_width / 12);
            invader.y = j * (game_screen_height / 18);
            invader.width = (game_screen_width / 18);
            invader.height = (game_screen_height / 24);
            invader.destroyed = false;
            vInvaders.push_back(invader);
        }
    }
}

void fn_vUpdateObjectsSizeOnScreen()
{
    // update the Paddle size on screen
    mPlayer.x = game_screen_width / 2;
    mPlayer.y = game_screen_height - game_screen_height / 9;
    mPlayer.width = game_screen_width / 12;
    mPlayer.height = game_screen_height / 24;
    //mPlayer.velocity = 0;

    // update the Player Bullets
    for (int i = 0; i < nbPlayerBullets; i++)
    {
        //        mPlayerBullet[i].active = 0;
        mPlayerBullet[i].x = game_screen_width / 2;
        mPlayerBullet[i].y = game_screen_height - game_screen_height / 9;
        mPlayerBullet[i].width = game_screen_width / 96;
        mPlayerBullet[i].height = game_screen_height / 48;
        mPlayerBullet[i].velocity_x = 0;
        mPlayerBullet[i].velocity_y = -5;
    }

    // update the invaders size on screen
    int k = 0;
    for (int i = 1; i < 11; i++) {
        for (int j = 2; j < 6; j++) {
            vInvaders[k].x = i * (game_screen_width / 12);
            vInvaders[k].y = j * (game_screen_height / 18);
            vInvaders[k].width = (game_screen_width / 18);
            vInvaders[k].height = (game_screen_height / 24);
            k++;
        }
    }
}


int APIENTRY WinMain(HINSTANCE hInst, HINSTANCE hInstPrev, PSTR cmdline, int cmdshow)
{

#if 0
    std::cout << "Hello World!\n";
    return 0;
#else
    // Initialize SDL
    if (SDL_Init(SDL_INIT_VIDEO) < 0)
    {
        std::cout << "SDL could not initialize! SDL_Error: " << SDL_GetError() << std::endl;
        return -1;
    }

    // Flag to track whether the window is in full screen mode
    bool fullScreen = false;

    // Get the actual screen dimensions
    SDL_DisplayMode displayMode;

    // SDL_GetCurrentDisplayMode(0, &screen_width, &screen_height);
    if (SDL_GetCurrentDisplayMode(0, &displayMode) == 0)
    {
        // Success! The current display mode is stored in the "displayMode" variable
        screen_width = displayMode.w;
        screen_height = displayMode.h;
        std::cout << "Success! The current display mode is stored in the displayMode variable, and we have " << screen_width << ", " << screen_height << std::endl;
    }
    else
    {
        // An error occurred. You can use SDL_GetError() to get the error message.
        std::cout << "An error occurred. You can use SDL_GetError() to get the error message" << std::endl;
        return -1;
    }

    // Calculate the dimensions of the game screen (as pixels)
    game_screen_width = screen_width * SCREEN_WIDTH_PERCENT / 100;
    game_screen_height = screen_height * SCREEN_HEIGHT_PERCENT / 100;

    // Create the window
    SDL_Window* window = SDL_CreateWindow("Space Invaders", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, game_screen_width, game_screen_height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);
    if (window == NULL)
    {
        std::cout << "Window could not be created! SDL_Error: " << SDL_GetError() << std::endl;
        return -1;
    }

    // Create the renderer
    SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);
    if (renderer == NULL)
    {
        std::cout << "Renderer could not be created! SDL_Error: " << SDL_GetError() << std::endl;
        return -1;
    }

    // Init Game Objects
    fn_vInitObjectsSizeOnScreen();

    // starfield
    generateStars();


    // Set the frame rate
    const int FPS = 60;
    const int frameDelay = 1000 / FPS;

    // Game loop
    bool running = true;
    bool bShoot = 0;
    while (running)
    {
        // Handle input


        // Handle events
        SDL_Event event;
        while (SDL_PollEvent(&event))
        {
            if (event.type == SDL_QUIT)
            {
                running = false;
            }
            if (event.type == SDL_WINDOWEVENT)
            {
                if (event.window.event == SDL_WINDOWEVENT_RESIZED)
                {
                    // Handle window resized event
                    game_screen_width = event.window.data1;
                    game_screen_height = event.window.data2;
                    // Do something with newWidth and newHeight
                    fn_vUpdateObjectsSizeOnScreen();
                    generateStars();
                }
            }
            if (event.type == SDL_KEYDOWN && event.key.keysym.sym == SDLK_f)
            {
                // Toggle full screen mode
                fullScreen = !fullScreen;
                SDL_SetWindowFullscreen(window, fullScreen ? SDL_WINDOW_FULLSCREEN_DESKTOP : 0);
            }
            if (event.type == SDL_KEYDOWN)
            {
                if (event.key.keysym.sym == SDLK_LEFT)
                {
                    mPlayer.velocity = -5;
                }
                else if (event.key.keysym.sym == SDLK_RIGHT)
                {
                    mPlayer.velocity = 5;
                }
                else if (event.key.keysym.sym == SDLK_SPACE) // bolean shoot !!!!!!!
                {
                    if (!bShoot)
                    {
                        bShoot = 1;

                        int iFirstAvailableSlot = 0;
                        for (int i = 0; i < nbPlayerBullets; i++)
                        {
                            if (mPlayerBullet[i].active == 0)
                            {
                                iFirstAvailableSlot = i;
                                break;
                            }
                        }
                        int i = iFirstAvailableSlot;
                        mPlayerBullet[i].active = 1;
                        mPlayerBullet[i].x = mPlayer.width + mPlayer.x;
                        mPlayerBullet[i].y = mPlayer.y;
                        mPlayerBullet[i].width = game_screen_width / 96;
                        mPlayerBullet[i].height = game_screen_height / 48;
                        mPlayerBullet[i].velocity_x = 0;
                        mPlayerBullet[i].velocity_y = -5;
                        mPlayerBullet[i + 1].active = 1;
                        mPlayerBullet[i + 1].x = mPlayer.width + mPlayer.x + game_screen_width / 24;
                        mPlayerBullet[i + 1].y = mPlayer.y;
                        mPlayerBullet[i + 1].width = game_screen_width / 96;
                        mPlayerBullet[i + 1].height = game_screen_height / 48;
                        mPlayerBullet[i + 1].velocity_x = 0;
                        mPlayerBullet[i + 1].velocity_y = -5;
                        mPlayerBullet[i + 2].active = 1;
                        mPlayerBullet[i + 2].x = mPlayer.width + mPlayer.x - game_screen_width / 24;
                        mPlayerBullet[i + 2].y = mPlayer.y;
                        mPlayerBullet[i + 2].width = game_screen_width / 96;
                        mPlayerBullet[i + 2].height = game_screen_height / 48;
                        mPlayerBullet[i + 2].velocity_x = 0;
                        mPlayerBullet[i + 2].velocity_y = -5;
                        mPlayerBullet[i + 3].active = 1;
                        mPlayerBullet[i + 3].x = mPlayer.width + mPlayer.x + 2 * game_screen_width / 24;
                        mPlayerBullet[i + 3].y = mPlayer.y;
                        mPlayerBullet[i + 3].width = game_screen_width / 96;
                        mPlayerBullet[i + 3].height = game_screen_height / 48;
                        mPlayerBullet[i + 3].velocity_x = 0;
                        mPlayerBullet[i + 3].velocity_y = -5;
                        mPlayerBullet[i + 4].active = 1;
                        mPlayerBullet[i + 4].x = mPlayer.width + mPlayer.x - 2 * game_screen_width / 24;
                        mPlayerBullet[i + 4].y = mPlayer.y;
                        mPlayerBullet[i + 4].width = game_screen_width / 96;
                        mPlayerBullet[i + 4].height = game_screen_height / 48;
                        mPlayerBullet[i + 4].velocity_x = 0;
                        mPlayerBullet[i + 4].velocity_y = -5;
                    }
                }
            }
            else if (event.type == SDL_KEYUP)
            {
                if (event.key.keysym.sym == SDLK_LEFT || event.key.keysym.sym == SDLK_RIGHT)
                {
                    mPlayer.velocity = 0;
                }
                else if (event.key.keysym.sym == SDLK_SPACE) // bolean shoot !!!!!!!
                {
                    if (bShoot)
                    {
                        bShoot = 0;
                    }
                }
            }
        }

        // Update game state
        mPlayer.update(game_screen_width);
        fn_vPlayerBullets_Update();
        for (unsigned int i = 0; i < vInvaders.size(); i++)
        {
            vInvaders[i].update();
        }

        // update the starfield
        updateStars(frameDelay);

        // Set the rendering color
        SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);

        // Clear the window
        SDL_RenderClear(renderer);
#if SCROLLING_STARFIELD
        // render starfield
        SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
        for (const Star& star : stars) 
        {
//            SDL_RenderDrawPoint(renderer, star.x, star.y);
            SDL_Rect starRect = { star.x, star.y, 3, 3 };
            SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
            SDL_RenderFillRect(renderer, &starRect);
        }
#else if
        // Draw stars
        for (const Star& star : stars) 
        {
            // Calculate star size based on depth
            int starSize = static_cast<int>(STAR_SIZE * (MAX_STAR_DEPTH - star.depth + 1));

            // Set star color based on depth
            int color = static_cast<int>((1 - star.depth / MAX_STAR_DEPTH) * 255);
            SDL_SetRenderDrawColor(renderer, color, color, color, 255);

            // Draw filled circle as star
            SDL_RenderFillCircle(renderer, star.x, star.y, starSize);
        }
#endif

        // Draw the player
        SDL_Rect playerRect = { mPlayer.x, mPlayer.y, mPlayer.width, mPlayer.height };
        SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
        SDL_RenderFillRect(renderer, &playerRect);

        // Draw the player bullets
        for (int i = 0; i < nbPlayerBullets; i++)
        {
            if (mPlayerBullet[i].active == 1)
            {
                SDL_Rect ballRect = { mPlayerBullet[i].x - mPlayerBullet[i].width,
                               mPlayerBullet[i].y - mPlayerBullet[i].height,
                               mPlayerBullet[i].width * 2, mPlayerBullet[i].height * 2 };
                SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
                SDL_RenderFillRect(renderer, &ballRect);
            }
        }

        // Draw the invaders
        for (unsigned int i = 0; i < vInvaders.size(); i++)
        {
            if (!vInvaders[i].destroyed)
            {
                SDL_Rect blockRect = { vInvaders[i].x, vInvaders[i].y, vInvaders[i].width, vInvaders[i].height };
                SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
                SDL_RenderFillRect(renderer, &blockRect);
            }
        }

        // Display the window
        SDL_RenderPresent(renderer);

        // Delay to achieve desired frame rate
        SDL_Delay(frameDelay);
    }

    // Clean up SDL
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    SDL_Quit();

    return 0;
#endif
}




// Run program: Ctrl + F5 or Debug > Start Without Debugging menu
// Debug program: F5 or Debug > Start Debugging menu

// Tips for Getting Started: 
//   1. Use the Solution Explorer window to add/manage files
//   2. Use the Team Explorer window to connect to source control
//   3. Use the Output window to see build output and other messages
//   4. Use the Error List window to view errors
//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project
//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file


