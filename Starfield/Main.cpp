
// SpaceInvaders_Game.cpp : This file contains the 'main' function. Program execution begins and ends there.
// Julien Merceron - 2023
// code generated by chatGPT
/*
ChatGPT Dec 15th 2022 Version
https://chat.openai.com/chat
*/
/*
SDL
https://github.com/libsdl-org/SDL/releases/tag/release-2.26.2
SDL2-devel-2.26.2-VC.zip
sdl/include
sdl/lib
wrt dlls, ...
... copy \SDL2\lib\x64\SDL2.dll to C:\Windows\System32
... and \SDL2\lib\x86\SDL2.dll to C:\Windows\SysWOW64. Voila
*/
/*
SDL Image
https://github.com/libsdl-org/SDL_image
TBC
*/
/*
create a CONSOLE APP on VC++
copy paste base code in c++ file
------
add include path to SDL in VC++ Directories
add lib path to SDL in VC++ Directories
add sdl2.lib in libs to link in Linker -> Input
change from console to windows in Linker -> System
*/
/*
PROMPT MODIFIERS
resolution_driven
add_comments
*/



#include <iostream>
#include "sdl.h"
#include "SDL_render.h"
//#include "sdl_image.h"
#include <windows.h>
#include <vector>

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>


// Screen dimensions (as percentages of the actual screen dimensions)
#define SCREEN_WIDTH 480
#define SCREEN_HEIGHT 360
const int SCREEN_WIDTH_PERCENT = 80;
const int SCREEN_HEIGHT_PERCENT = 80;
int screen_width, screen_height;
int game_screen_width;
int game_screen_height;


#include "sdl_Render_Circle.h"
#include "player_bullets_invaders.h"
#include "starfield.h"
#include "FireEffect.h"



static Uint16 pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0, tpos1, tpos2, tpos3, tpos4;
static int aSin[512];
static SDL_Color colors_plasma[256];


void fn_vDemoScene_ColorPalette_Plasma_init()
{
    int i;
    float rad;

    /*create sin lookup table */
    for (i = 0; i < 512; i++)
    {
        rad = ((float)i * 0.703125) * 0.0174532; /* 360 / 512 * degree to rad, 360 degrees spread over 512 values to be able to use AND 512-1 instead of using modulo 360*/
        aSin[i] = sin(rad) * 1024; /*using fixed point math with 1024 as base*/
    }

    /* create palette */
    for (i = 0; i < 64; ++i)
    {
        colors_plasma[i].r = i << 2;
        colors_plasma[i].g = 255 - ((i << 2) + 1);
        colors_plasma[i + 64].r = 255;
        colors_plasma[i + 64].g = (i << 2) + 1;
        colors_plasma[i + 128].r = 255 - ((i << 2) + 1);
        colors_plasma[i + 128].g = 255 - ((i << 2) + 1);
        colors_plasma[i + 192].g = (i << 2) + 1;
    }
}



void fn_vDemoScene_Plasma_Render(SDL_Window* window, SDL_Renderer* renderer)
{
    SDL_Surface* surface = SDL_GetWindowSurface(window);
    if (surface == NULL)
    {
        std::cout << "Surface could not be created! SDL_Error: " << SDL_GetError() << std::endl;
        return;
    }


#if 0
 
    SDL_UpdateWindowSurface(window);
    
    /* This is fast for surfaces that don't require locking. */
    /* Once locked, surface->pixels is safe to access. */
    SDL_LockSurface(surface);

    /* This assumes that color value zero is black. Use
        SDL_MapRGBA() for more robust surface color mapping! */
        /* height times pitch is the size of the surface's whole buffer. */
    SDL_memset(surface->pixels, 1, surface->h * surface->pitch);

    SDL_UnlockSurface(surface);

#else if
    Uint8* image;
    Uint16 i, j;
    Uint8 index;
    int x;

    /* Lock the screen for direct access to the pixels */
//    SDL_UpdateWindowSurface(window);
    SDL_LockSurface(surface);
//    SDL_memset(surface->pixels, 255, surface->h * surface->pitch);

    /*this is where it all happens */

    /* draw plasma */

    tpos4 = pos4;
    tpos3 = pos3;

    image = (Uint8 *)surface->pixels;

    for (i = 0; i < surface->h; ++i)
    {
        tpos1 = pos1 + 5;
        tpos2 = pos2 + 3;

        tpos3 &= 511;
        tpos4 &= 511;

        for (j = 0; j < surface->w; ++j)
        {
            tpos1 &= 511;
            tpos2 &= 511;

            x = aSin[tpos1] + aSin[tpos2] + aSin[tpos3] + aSin[tpos4]; /*actual plasma calculation*/

            index = 128 + (x >> 4); /*fixed point multiplication but optimized so basically it says (x * (64 * 1024) / (1024 * 1024)), x is already multiplied by 1024*/

//            *image++ = index;
/*
            SDL_Rect PlasmaPixelRect = { j,
                                            i,
                                        1, 1 };
            SDL_SetRenderDrawColor(renderer, index,
                                                index,
                                                index, 255);
            SDL_RenderFillRect(renderer, &PlasmaPixelRect);
*/
            tpos1 += 5;
            tpos2 += 3;
        }

        tpos4 += 3;
        tpos3 += 1;
    }

    /* move plasma */

    pos1 += 9;
    pos3 += 8;

    SDL_UnlockSurface(surface);
#endif
}



int APIENTRY WinMain(HINSTANCE hInst, HINSTANCE hInstPrev, PSTR cmdline, int cmdshow)
{

#if 0
    std::cout << "Hello World!\n";
    return 0;
#else
    // Initialize SDL
    if (SDL_Init(SDL_INIT_VIDEO) < 0)
    {
        std::cout << "SDL could not initialize! SDL_Error: " << SDL_GetError() << std::endl;
        return -1;
    }

    // Flag to track whether the window is in full screen mode
    bool fullScreen = false;

    // Get the actual screen dimensions
    SDL_DisplayMode displayMode;

    // SDL_GetCurrentDisplayMode(0, &screen_width, &screen_height);
    if (SDL_GetCurrentDisplayMode(0, &displayMode) == 0)
    {
        // Success! The current display mode is stored in the "displayMode" variable
        screen_width = displayMode.w;
        screen_height = displayMode.h;
        std::cout << "Success! The current display mode is stored in the displayMode variable, and we have " << screen_width << ", " << screen_height << std::endl;
    }
    else
    {
        // An error occurred. You can use SDL_GetError() to get the error message.
        std::cout << "An error occurred. You can use SDL_GetError() to get the error message" << std::endl;
        return -1;
    }

    // Calculate the dimensions of the game screen (as pixels)
    game_screen_width = screen_width * SCREEN_WIDTH_PERCENT / 100;
    game_screen_height = screen_height * SCREEN_HEIGHT_PERCENT / 100;

    // Create the window
    SDL_Window* window = SDL_CreateWindow("Starfield", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, game_screen_width, game_screen_height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);
    if (window == NULL)
    {
        std::cout << "Window could not be created! SDL_Error: " << SDL_GetError() << std::endl;
        return -1;
    }

    // Create the renderer
    SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);
    if (renderer == NULL)
    {
        std::cout << "Renderer could not be created! SDL_Error: " << SDL_GetError() << std::endl;
        return -1;
    }

    // Init Game Objects
    fn_vInitObjectsSizeOnScreen();

    // starfield
    generateStars();

    // Fire Color Palette
    fn_vDemoScene_ColorPalette_Fire_init();

    // Plasma Color Palette
    fn_vDemoScene_ColorPalette_Plasma_init();

    // Set the frame rate
    const int FPS = 60;
    const int frameDelay = 1000 / FPS;

    // Game loop
    bool running = true;
    bool bShoot = 0;
    while (running)
    {
        // Handle input


        // Handle events
        SDL_Event event;
        while (SDL_PollEvent(&event))
        {
            if ((event.type == SDL_QUIT)||(event.key.keysym.sym == SDLK_ESCAPE))
            {
                running = false;
            }
            if (event.type == SDL_WINDOWEVENT)
            {
                if (event.window.event == SDL_WINDOWEVENT_RESIZED)
                {
                    // Handle window resized event
                    game_screen_width = event.window.data1;
                    game_screen_height = event.window.data2;
                    // Do something with newWidth and newHeight
                    fn_vUpdateObjectsSizeOnScreen();
                    generateStars();
                }
            }
            if (event.type == SDL_KEYDOWN && event.key.keysym.sym == SDLK_f)
            {
                // Toggle full screen mode
                fullScreen = !fullScreen;
                SDL_SetWindowFullscreen(window, fullScreen ? SDL_WINDOW_FULLSCREEN_DESKTOP : 0);
            }
            if (event.type == SDL_KEYDOWN)
            {
                if (event.key.keysym.sym == SDLK_LEFT)
                {
                    mPlayer.velocity = -5;
                }
                else if (event.key.keysym.sym == SDLK_RIGHT)
                {
                    mPlayer.velocity = 5;
                }
                else if (event.key.keysym.sym == SDLK_SPACE) // bolean shoot !!!!!!!
                {
                    if (!bShoot)
                    {
                        bShoot = 1;

                        int iFirstAvailableSlot = 0;
                        for (int i = 0; i < nbPlayerBullets; i++)
                        {
                            if (mPlayerBullet[i].active == 0)
                            {
                                iFirstAvailableSlot = i;
                                break;
                            }
                        }
                        int i = iFirstAvailableSlot;
                        mPlayerBullet[i].active = 1;
                        mPlayerBullet[i].x = mPlayer.width + mPlayer.x;
                        mPlayerBullet[i].y = mPlayer.y;
                        mPlayerBullet[i].width = game_screen_width / 96;
                        mPlayerBullet[i].height = game_screen_height / 48;
                        mPlayerBullet[i].velocity_x = 0;
                        mPlayerBullet[i].velocity_y = -5;
                        mPlayerBullet[i + 1].active = 1;
                        mPlayerBullet[i + 1].x = mPlayer.width + mPlayer.x + game_screen_width / 24;
                        mPlayerBullet[i + 1].y = mPlayer.y;
                        mPlayerBullet[i + 1].width = game_screen_width / 96;
                        mPlayerBullet[i + 1].height = game_screen_height / 48;
                        mPlayerBullet[i + 1].velocity_x = 0;
                        mPlayerBullet[i + 1].velocity_y = -5;
                        mPlayerBullet[i + 2].active = 1;
                        mPlayerBullet[i + 2].x = mPlayer.width + mPlayer.x - game_screen_width / 24;
                        mPlayerBullet[i + 2].y = mPlayer.y;
                        mPlayerBullet[i + 2].width = game_screen_width / 96;
                        mPlayerBullet[i + 2].height = game_screen_height / 48;
                        mPlayerBullet[i + 2].velocity_x = 0;
                        mPlayerBullet[i + 2].velocity_y = -5;
                        mPlayerBullet[i + 3].active = 1;
                        mPlayerBullet[i + 3].x = mPlayer.width + mPlayer.x + 2 * game_screen_width / 24;
                        mPlayerBullet[i + 3].y = mPlayer.y;
                        mPlayerBullet[i + 3].width = game_screen_width / 96;
                        mPlayerBullet[i + 3].height = game_screen_height / 48;
                        mPlayerBullet[i + 3].velocity_x = 0;
                        mPlayerBullet[i + 3].velocity_y = -5;
                        mPlayerBullet[i + 4].active = 1;
                        mPlayerBullet[i + 4].x = mPlayer.width + mPlayer.x - 2 * game_screen_width / 24;
                        mPlayerBullet[i + 4].y = mPlayer.y;
                        mPlayerBullet[i + 4].width = game_screen_width / 96;
                        mPlayerBullet[i + 4].height = game_screen_height / 48;
                        mPlayerBullet[i + 4].velocity_x = 0;
                        mPlayerBullet[i + 4].velocity_y = -5;
                    }
                }
            }
            else if (event.type == SDL_KEYUP)
            {
                if (event.key.keysym.sym == SDLK_LEFT || event.key.keysym.sym == SDLK_RIGHT)
                {
                    mPlayer.velocity = 0;
                }
                else if (event.key.keysym.sym == SDLK_SPACE) // bolean shoot !!!!!!!
                {
                    if (bShoot)
                    {
                        bShoot = 0;
                    }
                }
            }
            else if (event.type == SDL_MOUSEBUTTONDOWN)
            {
                // Handle mouse input
                int mouseX, mouseY;
                SDL_GetMouseState(&mouseX, &mouseY); // Get the mouse position

                // create missile to the mouse position
                int iFirstAvailableSlot = 0;
                for (int i = 0; i < nbPlayerBullets; i++)
                {
                    if (mPlayerBullet[i].active == 0)
                    {
                        iFirstAvailableSlot = i;
                        break;
                    }
                }
                int i = iFirstAvailableSlot;
                mPlayerBullet[i].active = 1;
                mPlayerBullet[i].x = mouseX;
                mPlayerBullet[i].y = mouseY;
                mPlayerBullet[i].width = game_screen_width / 96;
                mPlayerBullet[i].height = game_screen_height / 48;
                mPlayerBullet[i].velocity_x = 0;
                mPlayerBullet[i].velocity_y = -5;
            }
        }

        // Update game state
        mPlayer.update(game_screen_width);
        fn_vPlayerBullets_Update();
        for (unsigned int i = 0; i < vInvaders.size(); i++)
        {
            vInvaders[i].update();
        }

        // update the starfield
        updateStars(frameDelay);

        // Set the rendering color
        SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);

        // Clear the window
        SDL_RenderClear(renderer);
#if SCROLLING_STARFIELD
        // render starfield
        SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
        for (const Star& star : stars)
        {
            //            SDL_RenderDrawPoint(renderer, star.x, star.y);
            SDL_Rect starRect = { star.x, star.y, 3, 3 };
            SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
            SDL_RenderFillRect(renderer, &starRect);
        }
#else if
        // Draw stars
        for (const Star& star : stars)
        {
            // Calculate star size based on depth
            int starSize = static_cast<int>(STAR_SIZE * (MAX_STAR_DEPTH - star.depth + 1));

            // Set star color based on depth
            int color = static_cast<int>((1 - star.depth / MAX_STAR_DEPTH) * 255);
            SDL_SetRenderDrawColor(renderer, color, color, color, 255);

            // Draw filled circle as star
            SDL_RenderFillCircle(renderer, star.x, star.y, starSize);
        }
#endif

        // fire effect
        fn_vDemoScene_Fire_Render(renderer);

        // plasma effect
        fn_vDemoScene_Plasma_Render(window, renderer);

        // Draw the player
        SDL_Rect playerRect = { mPlayer.x, mPlayer.y, mPlayer.width, mPlayer.height };
        SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
        SDL_RenderFillRect(renderer, &playerRect);

        // Draw the player bullets
        for (int i = 0; i < nbPlayerBullets; i++)
        {
            if (mPlayerBullet[i].active == 1)
            {
                SDL_Rect ballRect = { mPlayerBullet[i].x - mPlayerBullet[i].width,
                               mPlayerBullet[i].y - mPlayerBullet[i].height,
                               mPlayerBullet[i].width * 2, mPlayerBullet[i].height * 2 };
                SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
                SDL_RenderFillRect(renderer, &ballRect);
            }
        }

        // Draw the invaders
        for (unsigned int i = 0; i < vInvaders.size(); i++)
        {
            if (!vInvaders[i].destroyed)
            {
                SDL_Rect blockRect = { vInvaders[i].x, vInvaders[i].y, vInvaders[i].width, vInvaders[i].height };
                SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
                SDL_RenderFillRect(renderer, &blockRect);
            }
        }

        // Display the window
        SDL_RenderPresent(renderer);

        // Delay to achieve desired frame rate
        SDL_Delay(frameDelay);
    }

    // Clean up SDL
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    SDL_Quit();

    return 0;
#endif
}




// Run program: Ctrl + F5 or Debug > Start Without Debugging menu
// Debug program: F5 or Debug > Start Debugging menu

// Tips for Getting Started: 
//   1. Use the Solution Explorer window to add/manage files
//   2. Use the Team Explorer window to connect to source control
//   3. Use the Output window to see build output and other messages
//   4. Use the Error List window to view errors
//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project
//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file


