
// SpaceInvaders_Game.cpp : This file contains the 'main' function. Program execution begins and ends there.
// Julien Merceron - 2023
// code generated by chatGPT
/*
ChatGPT Dec 15th 2022 Version
https://chat.openai.com/chat
*/
/*
SDL
https://github.com/libsdl-org/SDL/releases/tag/release-2.26.2
SDL2-devel-2.26.2-VC.zip
sdl/include
sdl/lib
wrt dlls, ...
... copy \SDL2\lib\x64\SDL2.dll to C:\Windows\System32
... and \SDL2\lib\x86\SDL2.dll to C:\Windows\SysWOW64. Voila
*/
/*
SDL Image
https://github.com/libsdl-org/SDL_image
TBC
*/
/*
create a CONSOLE APP on VC++
copy paste base code in c++ file
------
add include path to SDL in VC++ Directories
add lib path to SDL in VC++ Directories
add sdl2.lib in libs to link in Linker -> Input
change from console to windows in Linker -> System
*/
/*
PROMPT MODIFIERS
resolution_driven
add_comments
*/



#include <iostream>
#include "sdl.h"
//#include "SDL_render.h"
//#include "sdl_image.h"
#include <windows.h>
#include <vector>



// Screen dimensions (as percentages of the actual screen dimensions)
const int SCREEN_WIDTH_PERCENT = 80;
const int SCREEN_HEIGHT_PERCENT = 80;
int screen_width, screen_height;
int game_screen_width;
int game_screen_height;


#include "sdl_Render_Circle.h"
#include "player_bullets_invaders.h"
#include "starfield.h"




int APIENTRY WinMain(HINSTANCE hInst, HINSTANCE hInstPrev, PSTR cmdline, int cmdshow)
{

#if 0
    std::cout << "Hello World!\n";
    return 0;
#else
    // Initialize SDL
    if (SDL_Init(SDL_INIT_VIDEO) < 0)
    {
        std::cout << "SDL could not initialize! SDL_Error: " << SDL_GetError() << std::endl;
        return -1;
    }

    // Flag to track whether the window is in full screen mode
    bool fullScreen = false;

    // Get the actual screen dimensions
    SDL_DisplayMode displayMode;

    // SDL_GetCurrentDisplayMode(0, &screen_width, &screen_height);
    if (SDL_GetCurrentDisplayMode(0, &displayMode) == 0)
    {
        // Success! The current display mode is stored in the "displayMode" variable
        screen_width = displayMode.w;
        screen_height = displayMode.h;
        std::cout << "Success! The current display mode is stored in the displayMode variable, and we have " << screen_width << ", " << screen_height << std::endl;
    }
    else
    {
        // An error occurred. You can use SDL_GetError() to get the error message.
        std::cout << "An error occurred. You can use SDL_GetError() to get the error message" << std::endl;
        return -1;
    }

    // Calculate the dimensions of the game screen (as pixels)
    game_screen_width = screen_width * SCREEN_WIDTH_PERCENT / 100;
    game_screen_height = screen_height * SCREEN_HEIGHT_PERCENT / 100;

    // Create the window
    SDL_Window* window = SDL_CreateWindow("Space Invaders", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, game_screen_width, game_screen_height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);
    if (window == NULL)
    {
        std::cout << "Window could not be created! SDL_Error: " << SDL_GetError() << std::endl;
        return -1;
    }

    // Create the renderer
    SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);
    if (renderer == NULL)
    {
        std::cout << "Renderer could not be created! SDL_Error: " << SDL_GetError() << std::endl;
        return -1;
    }

    // Init Game Objects
    fn_vInitObjectsSizeOnScreen();

    // starfield
    generateStars();


    // Set the frame rate
    const int FPS = 60;
    const int frameDelay = 1000 / FPS;

    // Game loop
    bool running = true;
    bool bShoot = 0;
    while (running)
    {
        // Handle input


        // Handle events
        SDL_Event event;
        while (SDL_PollEvent(&event))
        {
            if (event.type == SDL_QUIT)
            {
                running = false;
            }
            if (event.type == SDL_WINDOWEVENT)
            {
                if (event.window.event == SDL_WINDOWEVENT_RESIZED)
                {
                    // Handle window resized event
                    game_screen_width = event.window.data1;
                    game_screen_height = event.window.data2;
                    // Do something with newWidth and newHeight
                    fn_vUpdateObjectsSizeOnScreen();
                    generateStars();
                }
            }
            if (event.type == SDL_KEYDOWN && event.key.keysym.sym == SDLK_f)
            {
                // Toggle full screen mode
                fullScreen = !fullScreen;
                SDL_SetWindowFullscreen(window, fullScreen ? SDL_WINDOW_FULLSCREEN_DESKTOP : 0);
            }
            if (event.type == SDL_KEYDOWN)
            {
                if (event.key.keysym.sym == SDLK_LEFT)
                {
                    mPlayer.velocity = -5;
                }
                else if (event.key.keysym.sym == SDLK_RIGHT)
                {
                    mPlayer.velocity = 5;
                }
                else if (event.key.keysym.sym == SDLK_SPACE) // bolean shoot !!!!!!!
                {
                    if (!bShoot)
                    {
                        bShoot = 1;

                        int iFirstAvailableSlot = 0;
                        for (int i = 0; i < nbPlayerBullets; i++)
                        {
                            if (mPlayerBullet[i].active == 0)
                            {
                                iFirstAvailableSlot = i;
                                break;
                            }
                        }
                        int i = iFirstAvailableSlot;
                        mPlayerBullet[i].active = 1;
                        mPlayerBullet[i].x = mPlayer.width + mPlayer.x;
                        mPlayerBullet[i].y = mPlayer.y;
                        mPlayerBullet[i].width = game_screen_width / 96;
                        mPlayerBullet[i].height = game_screen_height / 48;
                        mPlayerBullet[i].velocity_x = 0;
                        mPlayerBullet[i].velocity_y = -5;
                        mPlayerBullet[i + 1].active = 1;
                        mPlayerBullet[i + 1].x = mPlayer.width + mPlayer.x + game_screen_width / 24;
                        mPlayerBullet[i + 1].y = mPlayer.y;
                        mPlayerBullet[i + 1].width = game_screen_width / 96;
                        mPlayerBullet[i + 1].height = game_screen_height / 48;
                        mPlayerBullet[i + 1].velocity_x = 0;
                        mPlayerBullet[i + 1].velocity_y = -5;
                        mPlayerBullet[i + 2].active = 1;
                        mPlayerBullet[i + 2].x = mPlayer.width + mPlayer.x - game_screen_width / 24;
                        mPlayerBullet[i + 2].y = mPlayer.y;
                        mPlayerBullet[i + 2].width = game_screen_width / 96;
                        mPlayerBullet[i + 2].height = game_screen_height / 48;
                        mPlayerBullet[i + 2].velocity_x = 0;
                        mPlayerBullet[i + 2].velocity_y = -5;
                        mPlayerBullet[i + 3].active = 1;
                        mPlayerBullet[i + 3].x = mPlayer.width + mPlayer.x + 2 * game_screen_width / 24;
                        mPlayerBullet[i + 3].y = mPlayer.y;
                        mPlayerBullet[i + 3].width = game_screen_width / 96;
                        mPlayerBullet[i + 3].height = game_screen_height / 48;
                        mPlayerBullet[i + 3].velocity_x = 0;
                        mPlayerBullet[i + 3].velocity_y = -5;
                        mPlayerBullet[i + 4].active = 1;
                        mPlayerBullet[i + 4].x = mPlayer.width + mPlayer.x - 2 * game_screen_width / 24;
                        mPlayerBullet[i + 4].y = mPlayer.y;
                        mPlayerBullet[i + 4].width = game_screen_width / 96;
                        mPlayerBullet[i + 4].height = game_screen_height / 48;
                        mPlayerBullet[i + 4].velocity_x = 0;
                        mPlayerBullet[i + 4].velocity_y = -5;
                    }
                }
            }
            else if (event.type == SDL_KEYUP)
            {
                if (event.key.keysym.sym == SDLK_LEFT || event.key.keysym.sym == SDLK_RIGHT)
                {
                    mPlayer.velocity = 0;
                }
                else if (event.key.keysym.sym == SDLK_SPACE) // bolean shoot !!!!!!!
                {
                    if (bShoot)
                    {
                        bShoot = 0;
                    }
                }
            }
        }

        // Update game state
        mPlayer.update(game_screen_width);
        fn_vPlayerBullets_Update();
        for (unsigned int i = 0; i < vInvaders.size(); i++)
        {
            vInvaders[i].update();
        }

        // update the starfield
        updateStars(frameDelay);

        // Set the rendering color
        SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);

        // Clear the window
        SDL_RenderClear(renderer);
#if SCROLLING_STARFIELD
        // render starfield
        SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
        for (const Star& star : stars)
        {
            //            SDL_RenderDrawPoint(renderer, star.x, star.y);
            SDL_Rect starRect = { star.x, star.y, 3, 3 };
            SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
            SDL_RenderFillRect(renderer, &starRect);
        }
#else if
        // Draw stars
        for (const Star& star : stars)
        {
            // Calculate star size based on depth
            int starSize = static_cast<int>(STAR_SIZE * (MAX_STAR_DEPTH - star.depth + 1));

            // Set star color based on depth
            int color = static_cast<int>((1 - star.depth / MAX_STAR_DEPTH) * 255);
            SDL_SetRenderDrawColor(renderer, color, color, color, 255);

            // Draw filled circle as star
            SDL_RenderFillCircle(renderer, star.x, star.y, starSize);
        }
#endif

        // Draw the player
        SDL_Rect playerRect = { mPlayer.x, mPlayer.y, mPlayer.width, mPlayer.height };
        SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
        SDL_RenderFillRect(renderer, &playerRect);

        // Draw the player bullets
        for (int i = 0; i < nbPlayerBullets; i++)
        {
            if (mPlayerBullet[i].active == 1)
            {
                SDL_Rect ballRect = { mPlayerBullet[i].x - mPlayerBullet[i].width,
                               mPlayerBullet[i].y - mPlayerBullet[i].height,
                               mPlayerBullet[i].width * 2, mPlayerBullet[i].height * 2 };
                SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
                SDL_RenderFillRect(renderer, &ballRect);
            }
        }

        // Draw the invaders
        for (unsigned int i = 0; i < vInvaders.size(); i++)
        {
            if (!vInvaders[i].destroyed)
            {
                SDL_Rect blockRect = { vInvaders[i].x, vInvaders[i].y, vInvaders[i].width, vInvaders[i].height };
                SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
                SDL_RenderFillRect(renderer, &blockRect);
            }
        }

        // Display the window
        SDL_RenderPresent(renderer);

        // Delay to achieve desired frame rate
        SDL_Delay(frameDelay);
    }

    // Clean up SDL
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    SDL_Quit();

    return 0;
#endif
}




// Run program: Ctrl + F5 or Debug > Start Without Debugging menu
// Debug program: F5 or Debug > Start Debugging menu

// Tips for Getting Started: 
//   1. Use the Solution Explorer window to add/manage files
//   2. Use the Team Explorer window to connect to source control
//   3. Use the Output window to see build output and other messages
//   4. Use the Error List window to view errors
//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project
//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file


